/*
 * Handling Interrupts
 *
 * This module is in charge of processing the interrupts
 * that are received in the pin 23.
 *
 * This module provides a handler for the interrupt that waits
 * 500ms after is executed to avoid bouncing (the switch(button) bounces
 * between high and low (5v, 0v) before the signal is stabilized).
 */

#include <linux/delay.h>
#include <linux/device.h>
#include <linux/gpio/consumer.h>
#include <linux/interrupt.h>
#include <linux/miscdevice.h>
#include <linux/module.h>
#include <linux/of.h>
#include <linux/platform_device.h>

static char *INTERRUPT_KEY_NAME = "PB_KEY";
static int irq;

/* Interrupt handler */
static irqreturn_t button_pressed_interrupt_handler(int irq, void *data) {
	struct device *dev = data;
	dev_info(dev, "interrupt received. Key %s\n", INTERRUPT_KEY_NAME);

	mdelay(500); /* Wait 500ms to avoid bouncing. */
	return IRQ_HANDLED;
}

static struct miscdevice button_miscdevice = {
	.minor = MISC_DYNAMIC_MINOR,
	.name = "button_dev",
};

/* Configures the Interrupt in the GPIO device. */
static int __init button_dev_probe(struct platform_device *pdev) {
	int ret;
	struct gpio_desc *gpio;
	struct device *dev = &pdev->dev;

	dev_info(dev, "button_dev_probe() function is called.\n");

	/* First method to get the Linux IRQ number */
	gpio = devm_gpiod_get(dev, NULL, GPIOD_IN);
	if (IS_ERR(gpio)) {
		dev_err(dev, "failed to get the interrupt number \n");
		return PTR_ERR(gpio);
	}
	irq = gpiod_to_irq(gpio);
	if (irq < 0) {
		return irq;
	}
	dev_info(dev, "First method: The IRQ number is: %d\n", irq);

	/* Second method to get the Linux IRQ number
	 *
	 * This method works fine the first time when the module is loaded,
	 * however, after removing the module and loading for second time,
	 * the function platform_get_irq() fails.
	 *
	irq = platform_get_irq(
		pdev,
		0 // IRQ index resource number
		);
	if (irq < 0) {
		dev_err(dev, "IRQ index number is not available\n");
		return -EINVAL;
	}
	dev_info(dev, "Second method: The IRQ number is %d\n", irq);
	*/

	/* Allocate the interrupt line */
	ret = devm_request_irq(dev,
		irq,
		button_pressed_interrupt_handler,
		IRQF_TRIGGER_FALLING,
		INTERRUPT_KEY_NAME,
		dev);
	if (ret) {
		dev_err(dev, "Failed to request interrupt %d, error %d\n", irq, ret);
		return ret;
	}

	ret = misc_register(&button_miscdevice);
	if (ret != 0) {
		dev_err(dev, "Could not register the misc device button_dev\n");
		return ret;
	}

	dev_info(dev, "button_dev: got minor %i\n", button_miscdevice.minor);
	dev_info(dev, "button_dev_probe() function is exited.\n");

	return 0;
}

static int __exit button_dev_remove(struct platform_device *pdev) {
	struct device *dev = &pdev->dev;

	dev_info(dev, "button_dev_remove() function is called.\n");
	dev_info(dev, "releasing IRQ %d\n", irq);
	devm_free_irq(dev, irq, dev);
	misc_deregister(&button_miscdevice);
	dev_info(dev, "button_dev_remove() function is exited.\n");

	return 0;
}

static const struct of_device_id of_ids[] = {
	{ .compatible = "button_dev,intkey" },
	{},
};

MODULE_DEVICE_TABLE(of, of_ids);

static struct platform_driver button_platform_driver = {
	.probe = button_dev_probe,
	.remove = button_dev_remove,
	.driver = {
		.name = "button_interrupt_driver",
		.of_match_table = of_ids,
		.owner = THIS_MODULE,
	}
};

module_platform_driver(button_platform_driver);

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Juan Yescas");
MODULE_DESCRIPTION("Platform Driver to process the interrupt generated by a button");

